
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>
    <h1 id="java">Java</h1>
<p>Resource : <a href="https://dev.java/learn/">https://dev.java/learn/</a></p>
<h2 id="oop-principles">OOP Principles</h2>
<ol>
<li>
<p>Encapsulation</p>
<p>It is the technique of bundling the data (variables) and the methods (functions) that operate on the data into a single unit called a class. Key principles of encapsulation are data hiding, access control</p>
</li>
<li>
<p>Inheritance</p>
</li>
<li>
<p>Polymorphism<br />
It refers to the ability of a single interface to support multiple underlying forms<br />
Compile-time Polymorphism - Achieved through method overloading.<br />
Runtime Polymorphism - Achieved through method overriding.</p>
</li>
<li>
<p>Abstraction<br />
Abstraction involves hiding the complex implementation details and showing only the essential features of an object. It focuses on the &quot;what&quot; an object does rather than &quot;how&quot; it does it.</p>
</li>
</ol>
<h2 id="solid-principles">SOLID Principles</h2>
<h3 id="single-responsibility-principle">Single responsibility principle</h3>
<p>every class should have only a single responsibility , or a single purpose</p>
<p>example : lets say we have a class for <code>bankingServices</code> , the class contains <code>deposit</code>, <code>withdraw</code>, <code>sentOTP</code>, <code>addLoan</code> methods . this class wont satisfy SRP , so we need to create separate classes for <code>sentOTP</code> and <code>sentEmail</code> say <code>notificationService</code> and separate class for adding loan say <code>LoanService</code></p>
<h3 id="open-and-close-principle">Open and close principle</h3>
<p>According to new requirements , classes should be open for extension but closed for modification.</p>
<p>example 1 :</p>
<p>lets say we have a class that can calculate area for shapes and the class have calc methods that take in circle and square, this doesn't satisfy OCP since lets say for ex we tried to calculate the area of a triangle we will have to modify the code.</p>
<p>example 2 :<br />
lets say we have a class for sending notification , this code will violate the OCP since if we need to add a new requirement to sent WhatsApp notification , we need to modify the code.</p>
<pre><code class="language-java">public class NotificationService {

	public void setNotification(String medium) {
	
			if(medium.equals(&quot;email&quot;)) {
				// sent email
			}
			
			if(medium.equals(&quot;sms&quot;)) {
				// sent sms
			}
	}

}
</code></pre>
<p>So we need to design our code in such a way that we can extend it based on new requirement. Here’s one of making it</p>
<p>create an interface for notification</p>
<pre><code class="language-java">public interface NotificationService {

	public void setNotification();

}
</code></pre>
<p>create Separate implementation for each kind of notification</p>
<pre><code class="language-java">public class EmailNotificationService implements NotificationService  {

	public void setNotification() {
				// sent email
	}

}
</code></pre>
<h3 id="liskovs-substitution-principle">Liskov’s Substitution principle</h3>
<p>Derived classes must be completely substitutable for their base class, in other words lets say we have class A which is a subtype of class B , then if we replace class A with class B program behavior should not be affected.</p>
<h3 id="interface-segregation-principle">Interface segregation principle</h3>
<p>Larger interface should be broken down into smaller ones so that implementation classes can only use what it need, we should not force clients to implement the methods they don't want.</p>
<h3 id="dependency-inversion-principle">Dependency inversion principle</h3>
<h2 id="design-patterns">Design patterns</h2>
<p>A <a href="https://www.geeksforgeeks.org/software-design-patterns/">design pattern is a generic repeatable solution to a frequently occurring problem in<br />
software design that is used in software engineering. It isn’t a complete design that can be written in code right away.</p>
<p>Creational design patterns</p>
<ul>
<li>singleton</li>
<li>Factory</li>
<li>Abstract Factory</li>
<li>Prototype</li>
<li>Builder</li>
</ul>
<p>Factory :</p>
<p>Factory Method Design Pattern define an interface for creating an object, but let subclass decide which class to instantiate. Factory Method lets a class defer instantiation to subclass.</p>
<p>example :</p>
<pre><code class="language-java">public interface MotorVehicle {
    void build();
}

public class Motorcycle implements MotorVehicle {
    @Override
    public void build() {
        System.out.println(&quot;Build Motorcycle&quot;);
    }
}

public class Car implements MotorVehicle {
    @Override
    public void build() {
        System.out.println(&quot;Build Car&quot;);
    }
}

public abstract class MotorVehicleFactory {
    public MotorVehicle create() {
        MotorVehicle vehicle = createMotorVehicle();
        vehicle.build();
        return vehicle;
    }
    protected abstract MotorVehicle createMotorVehicle();
}

public class MotorcycleFactory extends MotorVehicleFactory {
    @Override
    protected MotorVehicle createMotorVehicle() {
        return new Motorcycle();
    }
}

public class CarFactory extends MotorVehicleFactory {
    @Override
    protected MotorVehicle createMotorVehicle() {
        return new Car();
    }
}
</code></pre>

</body>
</html>
