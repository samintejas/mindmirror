
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Struct</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>
    <h1 id="struct">Struct</h1>
<p>A <em>struct</em>, or <em>structure</em>, is a custom data type that lets you package together and name multiple related values that make up a meaningful group. If you’re familiar with an object-oriented language, a <em>struct</em> is like an object’s data attributes.</p>
<p>Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean. Adding these names means that structs are more flexible than tuples: you don’t have to rely on the order of the data to specify or access the values of an instance.</p>
<p>Here's how you write a struct</p>
<pre><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
</code></pre>
<pre><code class="language-rust">fn main() {

		// a mutable instance of User 
    let mut user1 = User {
        active: true,
        username: String::from(&quot;someusername123&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };
		// updating the value
    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}
</code></pre>
<p>Note that the entire instance must be mutable; Rust doesn’t allow us to mark only certain fields as mutable.</p>
<pre><code class="language-rust">fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
</code></pre>
<p>this can be written in short as (<em>field init shorthand</em> syntax)</p>
<pre><code class="language-rust">fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
</code></pre>
<p>this is how to create a struct instance from another instance</p>
<pre><code class="language-rust">let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
</code></pre>
<p>this is the shorthand way to do it</p>
<pre><code class="language-rust">    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
</code></pre>
<p>Note that the struct update syntax uses <code>=</code> like an assignment; this is because it moves the data In this example, we can no longer use<code>user1</code> as a whole after creating <code>user2</code> because the <code>String</code> in the<code>username</code> field of <code>user1</code> was moved into <code>user2</code>. If we had given <code>user2</code> new <code>String</code> values for both <code>email</code> and <code>username</code>, and thus only used the<code>active</code> and <code>sign_in_count</code> values from <code>user1</code>, then <code>user1</code> would still be valid after creating <code>user2</code>. Both <code>active</code> and <code>sign_in_count</code> are types that implement the <code>Copy</code> trait so it is not a move since it is in the stack.</p>
<p>Rust also supports structs that look similar to tuples, called <em>tuple structs</em>. Tuple structs have the added meaning the struct name provides but don’t have names associated with their fields; rather, they just have the types of the fields. Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other tuples, and when naming each field as in a regular struct would be verbose or redundant.</p>
<pre><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre>
<p>You can also define structs that don’t have any fields! These are called <em>unit-like structs</em> because they behave similarly to <code>()</code>, the unit type that we mentioned in <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type">“The Tuple Type” section. Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.</p>
<pre><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre>
<p>Normally structs need to own all the fields inside it , so that the fields are valid till struct is valid . inorder to use reference inside struct , we need to use lifetime</p>
<p>this code wont work , because weve not added lifetime</p>
<pre><code class="language-rust">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: &quot;someusername123&quot;,
        email: &quot;someone@example.com&quot;,
        sign_in_count: 1,
    };
}
</code></pre>
<h2 id="method-syntax"><strong>Method Syntax</strong></h2>
<pre><code class="language-java">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// impl is used to define the area method within the Rectangle type
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a name, they can have parameters and a return value, and they contain some code that’s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an  enum or a trait object and their first parameter is always <code>self</code>, which represents the instance of the struct the method is being called on.</p>

</body>
</html>
