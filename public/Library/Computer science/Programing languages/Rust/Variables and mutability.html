
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variables and mutability</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>
    <h1 id="variables-and-mutability">Variables and mutability</h1>
<p>When a variable is immutable, once a value is bound to a name, you canâ€™t change that value. we will get a compile time error if we try to assign values to an immutable variable. we can use <code>mut</code> keyword to make a variable mutable.</p>
<p>Ultimately, deciding whether to use mutability or not is up to you and depends on what you think is clearest in that particular situation.</p>
<h2 id="constants">Constants</h2>
<p>Like immutable variables, <em>constants</em> are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</p>
<p>You declare constants using the <code>const</code> keyword instead of the <code>let</code> keyword and you cannot use <code>mut</code> .</p>
<p>ex :</p>
<pre><code class="language-rust">const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
</code></pre>
<h2 id="shadowing">Shadowing</h2>
<p>you can declare a new variable with the same name as a previous variable. Rustaceans say that the first variable is <em>shadowed</em> by the second, which means that the second variable is what the compiler will see when you use the name of the variable. we need to use <code>let</code> keyword for shadowing By using <code>let</code>, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed. We can even change the type with shadowing.</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
    let x = x + 1;
    
    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {x}&quot;);
    }

    println!(&quot;The value of x is: {x}&quot;);
    
    let spaces = &quot;   &quot;; // here type is string
    let spaces = spaces.len(); // here type is a number
}
</code></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it creates a new variable <code>x</code> by repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the value of <code>x</code> is then <code>6</code>. Then, within an inner scope created with the curly brackets, the third <code>let</code> statement also shadows <code>x</code> and creates a new variable, multiplying the previous value by <code>2</code> to give <code>x</code> a value of <code>12</code>. When that scope is over, the inner shadowing ends and <code>x</code> returns to being <code>6</code>. When we run this program, it will output the</p>

</body>
</html>
